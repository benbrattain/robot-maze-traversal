#pragma config(Sensor, in1,    potSensor,      sensorPotentiometer)
#pragma config(Sensor, in8,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  bump1,          sensorTouch)
#pragma config(Sensor, dgtl2,  Sonar,          sensorSONAR_inch)
#pragma config(Motor,  port2,  rightMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,  leftMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,  Servo,          tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// prototypes
void Right();
void Left();
void SLeft();
void SRight();
void Forward();
void Back();
void Stop();
void NaiveBump();
// assumes we have a stationary sonar facing left 
void LeftWalk();
// assumes we have a rotating sonar
void GapWalk();

// global vars
bool foundLight=false; // if we find the light
int rotCnt=0;
bool Done = false; // have you gotten to the light yet?

// main
task main() {	
	while(!foundLight) {
		NaiveBump();
		
		//LeftWalk();
		//GapWalk();
		Forward();
		checkfoundLight();
	}

	while(!Done){
		Forward();
		turnToLight();
		checkDone();
	}
}

void GapWalk() {
	int n,w,e;

	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
	}	

	if (rotCnt%2==0) {
		Motor[Servo]=-127;
		wait10Msec(10);
		w=SensorValue(Sonar);
		Motor[Servo]=0;
		wait10Msec(10);
		n=SensorValue(Sonar);
		Motor[Servo]=127;
		wait10Msec(10);
		e=SensorValue(Sonar);
	} else {
		Motor[Servo]=127;
		wait10Msec(10);
		e=SensorValue(Sonar);
		Motor[Servo]=0;
		wait10Msec(10);
		n=SensorValue(Sonar);
		Motor[Servo]=-127;
		wait10Msec(10);
		w=SensorValue(Sonar);
	}
	rotCnt++;
	if (n<=5) {
		Stop();
		Back();
		if (e>w) {
			Right();
		} else {
			Left();
		}
	}
	if ((e>=n) && (e>w)) {
		Stop();
		Right();
	}
	if ((w>=n) && (w>e)) {
		Stop();
		Left();
	}
}

void LeftWalk() {
	// wall hit (turn left)
	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
		Right();
		Forward();
	}
	int tmp = SensorValue(Sonar);
	// too far (slight left)
	if (tmp>=20) {
		Stop();
		Back();
		SLeft();
	}
	//wall gone (turn left)
	if (tmp>40) {
		Left();
	}
	// too close (slight right)
	if (tmp<=3) {
		Stop();
		Back();
		SRight();
	}
}

// naively go forward
// if bump, backup/turn left, go forward. 
// if bumped again, backup/turn right twice.
void NaiveBump() {
	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
		Left();
		Forward();
		if (SensorValue(bump1)!=0) {
			Stop();
			Back();
			Right();
			Right();
		  Forward();
			if (SensorValue(bump1)!=0) {
				Stop();
				Back();
				Right();
				Forward();
			}
		}
	}
}


void Stop() {
	Motor[rightMotor]=0;
	Motor[leftMotor]=0;
	wait10Msec(80);
}

// meticulous settings for 90deg turns and incremental steps forward/back
void Left() {
	Motor[leftMotor]=-80;
	Motor[rightMotor]=-80;
	wait10Msec(40);
	Stop();
}

void SLeft() {
	Motor[leftMotor]=-30;
	Motor[rightMotor]=-30;
	wait10Msec(30);
	Stop();
}

void Right() {
	Motor[rightMotor]=80;
	Motor[leftMotor]=80;
	wait10Msec(60);
	Stop();
}

void SRight() {
	Motor[leftMotor]=30;
	Motor[rightMotor]=30;
	wait10Msec(30);
	Stop();
}

void Forward() {
	Motor[leftMotor]=90;
	Motor[rightMotor]=-100;
	wait10Msec(50);
	Stop();
}

void Back() {
	Motor[leftMotor]=-90;
	Motor[rightMotor]=100;
	wait10Msec(50);
	Stop();
}

void scanLight(){
	int light = SensorValue(lightSensor);
	int minLight = 1000;
	int minPos;

	for (int i = -127; i < 127; i+= 3){
		ServeMove(i);
		light = SensorValue(lightSensor);

		//check for light source.
		if (!foundLight) {
			if(checkFoundLight(light)){
				break;
			}
		}

		//found light source, transition to checking for done.
		else{
			if(checkDone(light)){
				break;
			}
			//start finding minLight position in relation to servo position.
			else if(light < minLight){
				light = minLight;
				minPos = i;
			}
		}
	}
}
//Scans for light, if close enough, ends program.
bool checkFoundLight(int light){
	if (light <= 200) {
		foundLight = true;
		return true;
	}
	return false;
}

//turn to light based off of minLight position.
void turnToLight(){
}

void ServoMove(int servoPosition){
  motor[Servo] = servoPosition;
  wait1Msec(50);
}

void checkDone(){
	if (light <= 100) {
		Done = true;
		return true;
	}
}
