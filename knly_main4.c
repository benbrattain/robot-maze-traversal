#pragma config(Sensor, in1,    potSensor,      sensorPotentiometer)
#pragma config(Sensor, in8,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  bump1,          sensorTouch)
#pragma config(Sensor, dgtl2,  bump2,          sensorTouch)
#pragma config(Sensor, dgtl11, Sonar,          sensorSONAR_mm)
#pragma config(Motor,  port2,           rightmotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftmotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port4,           Servo,         tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
 
// prototypes
void Right();
void Left();
void SLeft();
void SRight();
void Forward();
void Back();
void Stop();
void NaiveBump();
// assumes we have a stationary sonar facing left
void LeftWalk();
// assumes we have a rotating sonar
void GapWalk();
void LookAround();
int newVal;
int savedSonar1;
int savedSonar2;
// global vars
//bool foundLight=false; // if we find the light
int rotCnt=0;
//bool Done = false; // have you gotten to the light yet?
bool northThere;
bool eastThere;
 
// main
task main() {
    while(true) {
        //NaiveBump();
        //LeftWalk();
        //GapWalk();
        //LookAround();

        Forward();
        MasterPlan();
        //checkfoundLight();
      //newVal = SensorValue(Sonar);
      //writeDebugStreamLine("%d",newVal);
    }
 
    //while(!Done){
    //  Forward();
    ////    turnToLight();
    ////    checkDone();
    //}
}
bool SonarDetect(int servoVal){
    motor[Servo] = servoVal;
    wait10Msec(60);
    newVal  = SensorValue(Sonar);
    writeDebugStreamLine("%d is sonarVal",newVal);
   
    if ( newVal <= 250){
        writeDebugStreamLine("true");
        return true;
    }
    else{
        writeDebugStreamLine("false");
        return false;
    }
 
}
void LookAround(){
        northThere= SonarDetect(85);
        savedSonar1=newVal;
        eastThere= SonarDetect(-100);
        savedSonar2=newVal;
       
        //lets not get too close to the wall
//      if(savedSonar2 < 50){
//          SLeft();
//      Forward();
//}
        if(northThere && eastThere){
            Left();
        }
       
     if(northThere && !eastThere){
 
            Right();
        }
        else {}
}
 
void GapWalk() {
    int n,w,e;
 
    if (SensorValue(bump1)!=0) {
        Stop();
        Back();
    }
 
    if (rotCnt%2==0) {
        motor[Servo]=-127;
        wait10Msec(10);
        w=SensorValue(Sonar);
        motor[Servo]=0;
        wait10Msec(10);
        n=SensorValue(Sonar);
        motor[Servo]=127;
        wait10Msec(10);
        e=SensorValue(Sonar);
    } else {
        motor[Servo]=127;
        wait10Msec(10);
        e=SensorValue(Sonar);
        motor[Servo]=0;
        wait10Msec(10);
        n=SensorValue(Sonar);
        motor[Servo]=-127;
        wait10Msec(10);
        w=SensorValue(Sonar);
    }
    rotCnt++;
    if (n<=5) {
        Stop();
        Back();
        if (e>w) {
            Right();
        } else {
            Left();
        }
    }
    if ((e>=n) && (e>w)) {
        Stop();
        Right();
    }
    if ((w>=n) && (w>e)) {
        Stop();
        Left();
    }
}
 
void LeftWalk() {
    // wall hit (turn left)
    if (SensorValue(bump1)!=0) {
        Stop();
        Back();
        Right();
        Forward();
    }
    int tmp = SensorValue(Sonar);
    // too far (slight left)
    if (tmp>=20) {
        Stop();
        Back();
        SLeft();
    }
    //wall gone (turn left)
    if (tmp>40) {
        Left();
    }
    // too close (slight right)
    if (tmp<=3) {
        Stop();
        Back();
        SRight();
    }
}
 
// naively go forward
// if bump, backup/turn left, go forward.
// if bumped again, backup/turn right twice.
void NaiveBump() {
    if (SensorValue(bump1)!=0) {
        Stop();
        Back();
        Left();
        Forward();
        if (SensorValue(bump1)!=0) {
            Stop();
            Back();
            Right();
            Right();
          Forward();
            if (SensorValue(bump1)!=0) {
                Stop();
                Back();
                Right();
                Forward();
            }
        }
    }
}
 
 
void Stop() {
    motor[rightmotor]=0;
    motor[leftmotor]=0;
    wait10Msec(30);
}
 
// meticulous settings for 90deg turns and incremental steps forward/back
void Left() {
    motor[leftmotor]=-70;
    motor[rightmotor]=-80;
    wait10Msec(40);
    Stop();
}
 
void SLeft() {
    motor[leftmotor]=-30;
    motor[rightmotor]=-30;
    wait10Msec(30);
    Stop();
}
 
void Right() {
    motor[rightmotor]=70;
    motor[leftmotor]=80;
    wait10Msec(60);
    Stop();
}
 
void SRight() {
    motor[leftmotor]=30;
    motor[rightmotor]=30;
    wait10Msec(30);
    Stop();
}
 
void Forward() {
    motor[leftmotor]=80;
    motor[rightmotor]=-120;
    wait10Msec(50);
    Stop();
}
 
void Back() {
    motor[leftmotor]=-90;
    motor[rightmotor]=120;
    wait10Msec(50);
    Stop();
}
 
//void scanLight(){
//  int light = SensorValue(lightSensor);
//  int minLight = 1000;
//  int minPos;
 
//  for (int i = -127; i < 127; i+= 3){
//      ServeMove(i);
//      light = SensorValue(lightSensor);
 
//      //check for light source.
//      if (!foundLight) {
//          if(checkFoundLight(light)){
//              break;
//          }
//      }
 
//      //found light source, transition to checking for done.
//      else{
//          if(checkDone(light)){
//              break;
//          }
//          //start finding minLight position in relation to servo position.
//          else if(light < minLight){
//              light = minLight;
//              minPos = i;
//          }
//      }
//  }
//}


void MasterPlan(){
    newVal  = SensorValue(Sonar);
    //if there is no wall to the right turn right
    if(newVal > 500){
        Stop();
        Right();
    }
    //if we are 300 mm from wall get closer to it
    else if(newVal >300){
        SRight();
    }
    //if we are less than 200 mm from wall get farther from it
    else if(newVal < 200){
        SLeft();
    }

    //if it bumps turn left
    if (SensorValue(bump1)!=0 || SensorValue(bump2)!=0) {
        Stop();
        Back();
        Left();
        Forward();

        //if it bumps again turn 180 (turning right from initial bump)
        if (SensorValue(bump1)!=0 || SensorValue(bump2)!=0) {
            Stop();
            Back();
            Right();
            Right();
          Forward();
          Forward();

          // if it bumps an extra time turn right (turning around from initial bump)

            if (SensorValue(bump1)!=0 || SensorValue(bump2)!=0) {
                Stop();
                Back();
                Right();
                Forward();
            }
        }
    }


}



////Scans for light, if close enough, ends program.
//bool checkFoundLight(int light){
//  if (light <= 200) {
//      foundLight = true;
//      return true;
//  }
//  return false;
//}
 
////turn to light based off of minLight position.
//void turnToLight(){
//}
 
//void ServoMove(int servoPosition){
//  motor[Servo] = servoPosition;
//  wait1Msec(50);
//}
 
//void checkDone(){
//  if (light <= 100) {
//      Done = true;
//      return true;
//  }
//}