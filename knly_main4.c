#pragma config(Sensor, in1,    potSensor,      sensorPotentiometer)
#pragma config(Sensor, in8,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  bump1,          sensorTouch)
#pragma config(Sensor, dgtl2,  Sonar,          sensorSONAR_inch)
#pragma config(Motor,  port2,  rightMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,  leftMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,  Servo,          tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// prototypes
void Right();
void Left();
void SLeft();
void SRight();
void Forward();
void Back();
void Stop();
void NaiveBump();
// assumes we have a stationary sonar facing left 
void LeftWalk();
// assumes we have a rotating sonar
void GapWalk();

// global vars
bool Done=false; // if we find the light
int rotCnt=0;

// main
task main() {	
	while(!Done) {
		NaiveBump();
		
		//LeftWalk();
		//GapWalk();
		Forward();
	}
}

void GapWalk() {
	int n,w,e;

	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
	}	

	if (rotCnt%2==0) {
		Motor[Servo]=-127;
		wait10Msec(10);
		w=SensorValue(Sonar);
		Motor[Servo]=0;
		wait10Msec(10);
		n=SensorValue(Sonar);
		Motor[Servo]=127;
		wait10Msec(10);
		e=SensorValue(Sonar);
	} else {
		Motor[Servo]=127;
		wait10Msec(10);
		e=SensorValue(Sonar);
		Motor[Servo]=0;
		wait10Msec(10);
		n=SensorValue(Sonar);
		Motor[Servo]=-127;
		wait10Msec(10);
		w=SensorValue(Sonar);
	}
	rotCnt++;
	if (n<=5) {
		Stop();
		Back();
		if (e>w) {
			Right();
		} else {
			Left();
		}
	}
	if ((e>=n) && (e>w)) {
		Stop();
		Right();
	}
	if ((w>=n) && (w>e)) {
		Stop();
		Left();
	}
}

void LeftWalk() {
	// wall hit (turn left)
	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
		Right();
		Forward();
	}
	int tmp = SensorValue(Sonar);
	// too far (slight left)
	if (tmp>=20) {
		Stop();
		Back();
		SLeft();
	}
	//wall gone (turn left)
	if (tmp>40) {
		Left();
	}
	// too close (slight right)
	if (tmp<=3) {
		Stop();
		Back();
		SRight();
	}
}

// naively go forward
// if bump, backup/turn left, go forward. 
// if bumped again, backup/turn right twice.
void NaiveBump() {
	if (SensorValue(bump1)!=0) {
		Stop();
		Back();
		Left();
		Forward();
		if (SensorValue(bump1)!=0) {
			Stop();
			Back();
			Right();
			Right();
		  Forward();
			if (SensorValue(bump1)!=0) {
				Stop();
				Back();
				Right();
				Forward();
			}
		}
	}
}


void Stop() {
	motor[rightMotor]=0;
	motor[leftMotor]=0;
	wait10Msec(80);
}

// meticulous settings for 90deg turns and incremental steps forward/back
void Left() {
	motor[leftMotor]=-80;
	motor[rightMotor]=-80;
	wait10Msec(40);
	Stop();
}

void SLeft() {
	Motor[leftMotor]=-30;
	Motor[rightMotor]=-30;
	wait10Msec(30);
	Stop();
}

void Right() {
	motor[rightMotor]=80;
	motor[leftMotor]=80;
	wait10Msec(60);
	Stop();
}

void SRight() {
	Motor[leftMotor]=30;
	Motor[rightMotor]=30;
	wait10Msec(30);
	Stop();
}

void Forward() {
	motor[leftMotor]=90;
	motor[rightMotor]=-100;
	wait10Msec(50);
	Stop();
}

void Back() {
	motor[leftMotor]=-90;
	motor[rightMotor]=100;
	wait10Msec(50);
	Stop();
}
